import { AccountBalanceQuery, AccountInfoQuery, AccountRecordsQuery, Client, Query, Transaction, TransactionReceiptQuery } from '@hashgraph/sdk';
export class HashConnectProvider {
    constructor(sender, networkName) {
        this.sender = sender;
        // super();
        this.client = Client.forName(networkName);
    }
    getLedgerId() {
        return this.client.ledgerId;
    }
    getNetwork() {
        return this.client.network;
    }
    getMirrorNetwork() {
        return this.client.mirrorNetwork;
    }
    getAccountBalance(accountId) {
        return new AccountBalanceQuery()
            .setAccountId(accountId)
            .execute(this.client);
    }
    getAccountInfo(accountId) {
        return new AccountInfoQuery()
            .setAccountId(accountId)
            .execute(this.client);
    }
    getAccountRecords(accountId) {
        return new AccountRecordsQuery()
            .setAccountId(accountId)
            .execute(this.client);
    }
    getTransactionReceipt(transactionId) {
        return new TransactionReceiptQuery()
            .setTransactionId(transactionId)
            .execute(this.client);
    }
    waitForReceipt(response) {
        return new TransactionReceiptQuery()
            .setNodeAccountIds([response.nodeId])
            .setTransactionId(response.transactionId)
            .execute(this.client);
    }
    async sendRequest(request) {
        const requestBytes = this.getBytesOf(request);
        const { signedTransaction, error } = await this.sender.send(request._operator.accountId, requestBytes);
        if (error) {
            throw new Error(`There was an issue while signing the request: ${error}`);
        }
        else if (request instanceof Transaction) {
            const sdkSignedTransaction = Transaction.fromBytes(signedTransaction);
            return sdkSignedTransaction.execute(this.client);
        }
        else if (request instanceof Query) {
            // TODO: execute query somehow?
            const sdkSignedTransaction = Query.fromBytes(signedTransaction);
            return sdkSignedTransaction.execute(this.client);
        }
        else {
            throw new Error(`We only know how to forward Transactions and Queries.`);
        }
    }
    getBytesOf(request) {
        if (request instanceof Transaction || request instanceof Query) {
            return request.toBytes();
        }
        else {
            throw new Error("Only Transactions and Queries can be serialized to be sent for signing by the HashPack wallet.");
        }
    }
}
//# sourceMappingURL=provider.js.map