import { Event } from "ts-typed-events";
import { WebSocketRelay } from "./types/relay";
import { MessageUtil, MessageHandler, RelayMessageType } from "./message";
import { HashConnectProvider } from "./provider/provider";
import { HashConnectSigner } from "./provider/signer";
global.Buffer = global.Buffer || require('buffer').Buffer;
/**
 * Main interface with hashpack
 */
export class HashConnect {
    constructor(debug) {
        this.publicKeys = {};
        this.debug = false;
        this.relay = new WebSocketRelay(this);
        this.foundExtensionEvent = new Event();
        this.foundIframeEvent = new Event();
        this.pairingEvent = new Event();
        this.transactionEvent = new Event();
        this.acknowledgeMessageEvent = new Event();
        this.additionalAccountRequestEvent = new Event();
        this.connectionStatusChange = new Event();
        this.authRequestEvent = new Event();
        this.messages = new MessageUtil();
        this.messageParser = new MessageHandler();
        if (debug)
            this.debug = debug;
        this.setupEvents();
    }
    async init(metadata, privKey) {
        return new Promise(async (resolve) => {
            this.metadata = metadata;
            if (this.debug)
                console.log("hashconnect - Initializing");
            if (!privKey)
                this.privateKey = await this.generateEncryptionKeys();
            else
                this.privateKey = privKey;
            metadata.publicKey = this.privateKey;
            let initData = {
                privKey: this.privateKey
            };
            if (window)
                this.metadata.url = window.location.origin;
            await this.relay.init();
            if (this.debug)
                console.log("hashconnect - Initialized");
            resolve(initData);
        });
    }
    async connect(topic, metadataToConnect) {
        if (!topic) {
            topic = this.messages.createRandomTopicId();
            this.publicKeys[topic] = this.privateKey;
            if (this.debug)
                console.log("hashconnect - Created new topic id - " + topic);
        }
        if (metadataToConnect)
            this.publicKeys[topic] = metadataToConnect.publicKey;
        let state = {
            topic: topic,
            expires: 0
        };
        await this.relay.subscribe(state.topic);
        return state;
    }
    /**
     * Set up event connections
     */
    setupEvents() {
        // This will listen for a payload emission from the relay
        if (this.debug)
            console.log("hashconnect - Setting up events");
        this.relay.payload.on(async (payload) => {
            if (!payload)
                return;
            //this is redundant until protobuffs are re-implemented
            const message = await this.messages.decode(payload, this);
            await this.messageParser.onPayload(message, this);
        });
    }
    /**
     * Send functions
     */
    async sendTransaction(topic, transaction) {
        transaction.byteArray = Buffer.from(transaction.byteArray).toString("base64");
        const msg = await this.messages.prepareSimpleMessage(RelayMessageType.Transaction, transaction, topic, this);
        await this.relay.publish(topic, msg, this.publicKeys[topic]);
        this.sendEncryptedLocalTransaction(msg);
        return await new Promise(resolve => this.transactionResolver = resolve);
    }
    async requestAdditionalAccounts(topic, message) {
        const msg = await this.messages.prepareSimpleMessage(RelayMessageType.AdditionalAccountRequest, message, topic, this);
        await this.relay.publish(topic, msg, this.publicKeys[topic]);
        return await new Promise(resolve => this.additionalAccountResolver = resolve);
    }
    async sendAdditionalAccounts(topic, message) {
        message.accountIds = message.accountIds.map(id => { return id; });
        const msg = await this.messages.prepareSimpleMessage(RelayMessageType.AdditionalAccountResponse, message, topic, this);
        await this.relay.publish(topic, msg, this.publicKeys[topic]);
        return message.id;
    }
    async sendTransactionResponse(topic, message) {
        if (message.receipt)
            message.receipt = Buffer.from(message.receipt).toString("base64");
        if (message.signedTransaction)
            message.signedTransaction = Buffer.from(message.signedTransaction).toString("base64");
        const msg = await this.messages.prepareSimpleMessage(RelayMessageType.TransactionResponse, message, topic, this);
        await this.relay.publish(topic, msg, this.publicKeys[topic]);
        return message.id;
    }
    async pair(pairingData, accounts, network) {
        if (this.debug)
            console.log("hashconnect - Pairing to " + pairingData.metadata.name);
        let state = await this.connect(pairingData.topic);
        let msg = {
            metadata: this.metadata,
            topic: pairingData.topic,
            accountIds: accounts,
            network: network
        };
        msg.metadata.description = this.sanitizeString(msg.metadata.description);
        msg.metadata.name = this.sanitizeString(msg.metadata.name);
        msg.metadata.publicKey = pairingData.metadata.publicKey;
        msg.network = this.sanitizeString(msg.network);
        msg.metadata.url = this.sanitizeString(msg.metadata.url);
        msg.accountIds = msg.accountIds.map(id => { return id; });
        this.publicKeys[pairingData.topic] = pairingData.metadata.publicKey;
        const payload = await this.messages.prepareSimpleMessage(RelayMessageType.ApprovePairing, msg, msg.topic, this);
        this.relay.publish(pairingData.topic, payload, this.publicKeys[pairingData.topic]);
        return state;
    }
    async reject(topic, reason, msg_id) {
        let reject = {
            reason: reason,
            topic: topic,
            msg_id: msg_id
        };
        reject.reason = this.sanitizeString(reject.reason);
        // create protobuf message
        const msg = await this.messages.prepareSimpleMessage(RelayMessageType.RejectPairing, reject, topic, this);
        // Publish the rejection
        await this.relay.publish(topic, msg, this.publicKeys[topic]);
    }
    async acknowledge(topic, pubKey, msg_id) {
        const ack = {
            result: true,
            topic: topic,
            msg_id: msg_id
        };
        const ackPayload = await this.messages.prepareSimpleMessage(RelayMessageType.Acknowledge, ack, topic, this);
        await this.relay.publish(topic, ackPayload, pubKey);
    }
    async authenticate(topic, account_id, server_signing_account, serverSignature, payload) {
        let message = {
            topic: topic,
            accountToSign: account_id,
            serverSigningAccount: server_signing_account,
            serverSignature: serverSignature,
            payload: payload
        };
        message.serverSignature = Buffer.from(message.serverSignature).toString("base64");
        console.log(message.serverSignature);
        const msg = await this.messages.prepareSimpleMessage(RelayMessageType.AuthenticationRequest, message, topic, this);
        await this.relay.publish(topic, msg, this.publicKeys[topic]);
        this.sendEncryptedLocalTransaction(msg);
        return await new Promise(resolve => this.authResolver = resolve);
    }
    async sendAuthenticationResponse(topic, message) {
        if (message.userSignature)
            message.userSignature = Buffer.from(message.userSignature).toString("base64");
        if (message.signedPayload)
            message.signedPayload.serverSignature = Buffer.from(message.signedPayload.serverSignature).toString("base64");
        const msg = await this.messages.prepareSimpleMessage(RelayMessageType.AuthenticationResponse, message, topic, this);
        await this.relay.publish(topic, msg, this.publicKeys[topic]);
        return message.id;
    }
    /**
     * Helpers
     */
    generatePairingString(state, network, multiAccount) {
        if (this.debug)
            console.log("hashconnect - Generating pairing string");
        let data = {
            metadata: this.metadata,
            topic: state.topic,
            network: network,
            multiAccount: multiAccount
        };
        data.metadata.description = this.sanitizeString(data.metadata.description);
        data.metadata.name = this.sanitizeString(data.metadata.name);
        data.network = this.sanitizeString(data.network);
        data.metadata.url = this.sanitizeString(data.metadata.url);
        let pairingString = Buffer.from(JSON.stringify(data)).toString("base64");
        return pairingString;
    }
    decodePairingString(pairingString) {
        let json_string = Buffer.from(pairingString, 'base64').toString();
        let data = JSON.parse(json_string);
        // data.metadata.publicKey = Buffer.from(data.metadata.publicKey as string, 'base64');
        return data;
    }
    async generateEncryptionKeys() {
        let key = this.messages.createRandomTopicId();
        if (this.debug)
            console.log("hashconnect - Generated new encryption key - " + key);
        return key;
    }
    sanitizeString(str) {
        return str.replace(/[^\w. ]/gi, function (c) {
            if (c == ".")
                return ".";
            return '&#' + c.charCodeAt(0) + ';';
        });
    }
    /**
     * Local wallet stuff
     */
    findLocalWallets() {
        if (this.debug)
            console.log("hashconnect - Finding local wallets");
        window.addEventListener("message", (event) => {
            if (event.data.type && (event.data.type == "hashconnect-query-extension-response")) {
                if (this.debug)
                    console.log("hashconnect - Local wallet metadata recieved", event.data);
                if (event.data.metadata)
                    this.foundExtensionEvent.emit(event.data.metadata);
            }
            if (event.data.type && event.data.type == "hashconnect-iframe-response") {
                if (this.debug)
                    console.log("hashconnect - iFrame wallet metadata recieved", event.data);
                if (event.data.metadata)
                    this.foundIframeEvent.emit(event.data.metadata);
            }
        }, false);
        setTimeout(() => {
            window.postMessage({ type: "hashconnect-query-extension" }, "*");
            if (window.parent)
                window.parent.postMessage({ type: "hashconnect-iframe-query" }, '*');
        }, 50);
    }
    connectToIframeParent(pairingString) {
        window.parent.postMessage({ type: "hashconnect-iframe-pairing", pairingString: pairingString }, '*');
    }
    connectToLocalWallet(pairingString) {
        if (this.debug)
            console.log("hashconnect - Connecting to local wallet");
        //todo: add extension metadata support
        window.postMessage({ type: "hashconnect-connect-extension", pairingString: pairingString }, "*");
    }
    sendEncryptedLocalTransaction(message) {
        if (this.debug)
            console.log("hashconnect - sending local transaction", message);
        window.postMessage({ type: "hashconnect-send-local-transaction", message: message }, "*");
    }
    async decodeLocalTransaction(message) {
        const local_message = await this.messages.decode(message, this);
        return local_message;
    }
    /**
     * Provider stuff
     */
    getProvider(network, topicId, accountToSign) {
        return new HashConnectProvider(network, this, topicId, accountToSign);
    }
    getSigner(provider) {
        return new HashConnectSigner(this, provider, provider.accountToSign, provider.topicId);
    }
}
//# sourceMappingURL=hashconnect.js.map